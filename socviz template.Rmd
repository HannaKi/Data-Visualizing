---
title: "Data Visualization Notes"
author: "Kieran Healy"
date: "2019-01-02"
output: html_document
---
   
## Data Visualization Notes

This is a starter RMarkdown template to accompany *Data Visualization* (Princeton University Press, 2019). You can use it to take notes, write your code, and produce a good-looking, reproducible document that records the work you have done. At the very top of the file is a section of *metadata*, or information about what the file is and what it does. The metadata is delimited by three dashes at the start and another three at the end. You should change the title, author, and date to the values that suit you. Keep the `output` line as it is for now, however. Each line in the metadata has a structure. First the *key* ("title", "author", etc), then a colon, and then the *value* associated with the key.  

## This is an RMarkdown File

Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. A *code chunk* is a specially delimited section of the file. You can add one by moving the cursor to a blank line choosing Code > Insert Chunk from the RStudio menu. When you do, an empty chunk will appear:

```{r}
## Onpa hienoa!

```

```{r}

```

Code chunks are delimited by three backticks (found to the left of the 1 key on US and UK keyboards) at the start and end. The opening backticks also have a pair of braces and the letter `r`, to indicate what language the chunk is written in. You write your code inside the code chunks. Write your notes and other material around them, as here. 

## Before you Begin

To install the tidyverse, make sure you have an Internet connection. Then *manually* run the code in the chunk below. If you knit the document if will be skipped. We do this because you only need to install these packages once, not every time you run this file. Either knit the chunk using the little green "play" arrow to the right of the chunk area, or copy and paste the text into the console window.

```{r install, eval = FALSE}

## This code will not be evaluated automatically.
## (Notice the eval = FALSE declaration in the options section of the
## code chunk)

my_packages <- c("tidyverse", "broom", "coefplot", "cowplot",
                 "gapminder", "GGally", "ggrepel", "ggridges", "gridExtra",
                 "here", "interplot", "margins", "maps", "mapproj",
                 "mapdata", "MASS", "quantreg", "rlang", "scales",
                 "survey", "srvyr", "viridis", "viridisLite", "devtools", "knitr", "socviz")

lisapaketit <- c("tree")

install.packages(my_packages, lisapaketit, repos = "http://cran.rstudio.com")

```

## Set Up Your Project and Load Libraries

To begin we must load some libraries we will be using. If we do not load them, R will not be able to find the functions contained in these libraries. The tidyverse includes ggplot and other tools. We also load the socviz and gapminder libraries.

```{r setup, include=FALSE}

## By defult, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(echo = TRUE) 

## Set the default size of figures
knitr::opts_chunk$set(fig.width=8, fig.height=5)  

## Load the libraries we will be using
library(gapminder)
library(here)
library(socviz)
library(tidyverse)

```

Notice that here, the braces at the start of the code chunk have some additional options set in them. There is the language, `r`, as before. This is required. Then there is the word `setup`, which is a label for your code chunk. Labels are useful to briefly say what the chunk does. Label names must be unique (no two chunks in the same document can have the same label) and cannot contain spaces. Then, after the comma, an option is set: `include=FALSE`. This tells R to run this code but not to include the output in the final document. 
```{r}
# eli edellisen kappaleen ylapuolella on
# koodia, jota ei tulosteta html-tiedostoon
```


When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r look}
gapminder
```

The remainder of this document contains the chapter headings for the book, and an empty code chunk in each section to get you started. Try knitting this document now by clicking the "Knit" button in the RStudio toolbar, or choosing File > Knit Document from the RStudio menu.

## Look at Data

```{r}

```


## Get Started

Muistiinpanoja: 

- "it’s better to think of the data and code as what’s real, together with the text you write."

- "The reality for most of us is that the person who will most want to easily reproduce your work is you, six months or a year from now."

- "While a script file can keep comments and code together, it loses *the connection between code and its output*, such as the figure we want to produce. But there is a better alternative: we can write our notes using RMarkdown."

```{r}
# Ctrl+Alt+I Windowsilla antaa tallaisen koodipalan. (Enta Linux?)
```


```{r}

```


## Make a Plot

```{r}
summary(gapminder)
```


Katsotaan datan muuttujien nimet

```{r}
colnames(gapminder)
```

Niista saadaan elementit kuvaajan piirtamiseen

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp,
                          size = pop,
                          color = continent)) +
                          geom_point() +
                          coord_cartesian() +
                          scale_x_log10() +
                          labs(x = "log GDP", y = "Life expectancy",
                          title = "kuvaaja")

# piirra tulostamalla "p"
p
```


"An aesthetic mapping **aes** specifies that a **variable** will be expressed by one of the available visual elements, such as size, or color, or shape, and so on."

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp,
                          color = "purple"))+
  geom_point() +
    geom_smooth(method = "loess") +
    scale_x_log10() + 
    labs(title = "aes-funktioon annettu varimaarittely VaaRIN.", subtitle = "ggplotille annetaan vain datan muutujia, nyt se on luonut kokonaan uuden muuttujan, 'purple'")

p

```

"The aes() function is for mappings only. Do not use it to change properties to a particular value."!!!

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp))
p + geom_point(color = "purple") +
    geom_smooth(method = "loess") +
    scale_x_log10() + 
    labs(title = "Varin voi maarittaa geom-funktiolle mutta se ei tuo tassa lisaa tietoa")
```

ggplot koostuu kerroksista, jossa jokainen kerroksen funktio voi kayttaa omia parametrejaan:

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp)) 
p + geom_point(alpha = 0.3) +
    geom_smooth(color = "orange", se = FALSE, size = 8, method = "lm") +
    scale_x_log10()
```

- "'alpha' is an aesthetic property that points (and some other plot elements) have, and to which variables can be mapped"

- Choosing an intermediate alpha-value can be useful when there is a lot of overlapping data to plot

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y=lifeExp))

p+  geom_point(alpha = 0.3) +
    geom_smooth(method = "gam") +
    scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita", y = "Life Expectancy in Years",
         title = "Economic Growth and Life Expectancy",
         subtitle = "Data points are country-years",
         caption = "Source: Gapminder.")
```

Huomaa kuvaajassa ylla hieno otsikointi ja lahdeviitteet, jotka on tehty labs-funktiolla. Akselien asteikon $-merkki tulee kuitenkin scale-funktion parametrina

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp,
                          color = continent,
                          fill = continent))
p + geom_point() +
    geom_smooth(method = "loess") +
    scale_x_log10()
```
- Kun ggplotille annetaan piirrettavaksi uusi muuttuja, muuttuja "periytyy" kaikille lisamaarittelyja tekeville funktioille. Siksi kaikille conitnent-muuttujille tulee oma regressiokayra. 

- huomaa fill, joka varittaa taytettavissa olevat alat

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_point(mapping = aes(color = continent)) +
    geom_smooth(method = "loess") +
    scale_x_log10()
```

Jos geom_funktiolle maarittaa erikseen, mita muuttujia sen avulla haluaa piirtaa, periytymista voi rajoittaa.

Myös jatkuva muuttuja voi maarata varin

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp))
p + geom_point(mapping = aes(color = log(pop))) +
    scale_x_log10()
```

Kuvaajan tallenteminen toimii here-funktion avulla

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp)) +
    geom_point(mapping = aes(color = log(pop))) +
    scale_x_log10()

ggsave(here("output", "figures", "testikuvaaja.png"), plot = p)
```

### Kokeiluja 

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_point(mapping = aes(color = continent)) +
    geom_smooth(method = "loess") +
    scale_x_log10() + 
    labs(title = "Alkuperainen kuvaaja")
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_x_log10() + 
    labs(title = "geom_smooth ennen geom_pointia")
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = pop, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_x_log10() + 
    labs(title = "Elinaika suhteessa populaatioon")
```
Tulkinta: Elinajanennuste on alhaisin Afrikassa. Elinajanennuste on keskimaarin hieman korkeampi maissa, joissa on suuri vaestö.

Kokeiluja akseleilla

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_y_log10() 
```

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_x_sqrt() 
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_x_reverse() 
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) 
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = year)) +
    scale_x_log10() + 
    labs(title="varimaareena vuosi eika manner")
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = factor(year))) +
    scale_x_log10() + 
    labs(title="varimaareena vuosi eika manner HUOM! factor(year)!!!!")
```

```{r}
gapminder2 <- filter(gapminder, year == 2007)
p <- ggplot(data = gapminder2, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_x_log10() 
```


## Show the Right Numbers

Allaolevassa kuvaajassa, jossa piirretaan kahta jatkuvaa muuttujaa, muuttujissa itsessaan ei ole ryhmittelya (kuten manner tai maa). Taman vuoksi ggplotille kerrotaan, etta jokainen vuosi kuuluu jollekkin maalle, eli aes(group=country). Nain jokaiselle maalle piirtyy oma viivansa.

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = year,
                          y = gdpPercap))
p + geom_line(aes(group=country)) 
```

### Ruudukot tiedon esittamisen apuna

Fasetilla voidaan jakaa kuva useampaan ruutuun luokittelevan muuttujan perusteella. Kuvat listautuvat perakkain, tai voit maarittaa, montako kuvaa haluat rinnakkain.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))

p + geom_line(aes(group = country)) + facet_wrap(~ continent)
```

```{r}
p <- ggplot(gapminder, aes(year, gdpPercap)) + geom_line(color = "gray", aes(group = country)) + geom_smooth(method = loess, se = F) + scale_y_log10(labels=scales::dollar) + facet_wrap(~ continent, ncol = 5) + labs(x= "vuosi", y = "BKT/hlö", title="BKT henkilöa kohden viidella mantereella") 

# + theme(axis.title.x = element_text(angle = 90, vjust = 0.25))
# Miten muokataan fasettien akseleita?
p

ggsave(here("output", "figures", "BKT_per_hlo_mantereittain.jpg"), plot = p)
```
```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp)) 
p + geom_point(alpha = 0.3) +
    geom_smooth(color = "orange", se = FALSE, method = "lm") +
    scale_x_log10()+facet_wrap(~continent)
```
### Siirrytaan dataan, jossa luokittelevia muuttujia

gss_sm on yhteiskuntatieteellisen tutkimuksen dataa. Muuttujista moni on *luokitteleva* tai *jarjestysasteikollinen*

-  because we are *cross-classifying* our results, the formula is two-sided: *facet_grid(sex ~ race)*.

```{r}
p <- ggplot(data = gss_sm, aes(age, childs))
p + geom_point(alpha = 0.2)+geom_smooth()+facet_grid(sex~race)
```
Ruudukkoon voi ottaa useamman tekijan, mutta tulkitseminen menee hankalaksi eika datakaan valttamatta enaa riita.

```{r}
p <- ggplot(data = gss_sm, aes(age, childs))
p + geom_point(alpha = 0.2)+geom_smooth()+facet_grid(sex~race~obama)
```

### Pylvasdiagrammi

Pylvaskuvaajalla kuvataan luokittelevia muuttujia.

Jokaiseen geom_-funktioon liittyy stat_funktio, joka tulee kutsustuksi automaattisesti, ellei toisin maariteta.

Pylvasdiagrammille stat on count, eli maara, jonka funktio laskee datasta kuvaajalle "lennosta".

```{r}
p <- ggplot(gss_sm, aes(x=bigregion))
p + geom_bar(mapping = aes(fill=bigregion))
```
Jos kuvaajaan halutaan muutujan arvojen osuudet, tulee kayttaa toista geom_bar:in stat-funktiota, ..prop..:ia. Huomaa erikoinen merkinta!

Lisaksi funktiokutsulle on maariettava, etta sen ei tule jakaa dataa osiin x-akselille, vaan x-akselin arvot summautuvat yhteen. 

```{r}
p <- ggplot(gss_sm, aes(x=bigregion))
p + geom_bar(mapping = aes(y = ..prop.., fill=bigregion)) + labs(title="Tassa muuttuja ei summaudu yhteen", subtitle = "Vaan jokainen arvo summautuu yhteen")
```

Muuttuja saadaan summautumaan yhteen dummy-muuttujalla, group = 1.

```{r}
p <- ggplot(gss_sm, aes(bigregion))
p + geom_bar(color= "blue", fill= "orange", mapping = aes(y=..prop.., group=1))
```
Huomaa, fill=bigregion ei enaa, toimi, koska muuttujassa ei ole enaa useampaa luokkaa, vaan yksi dummy!

### Frequency plots the slightly awkward way

fill-parametrin paras kayttökohde on kolmannen muuttujan tuominen kuvaajaan varittamalla kaavion pylvaat sen mukaan

```{r}
p <- ggplot(gss_sm, mapping = aes(bigregion, fill = religion))
p + geom_bar()
```

Pinottu pylvas on pylvasdiagrammin oletus. Tata voidaan muuttaa "position"-argumentilla

```{r}
p <- ggplot(gss_sm, mapping = aes(bigregion, fill = religion))
p + geom_bar(position = "fill")
```
Vertailu ryhmien sisalla on nain helppoa, mutta ryhmien kesken vaikeaa. "dodge" asettaa pylvaat rinnakkain, mutta sellaisenaan se antaa datan lukumaarat

```{r}
p <- ggplot(gss_sm, mapping = aes(bigregion, fill = religion))
p + geom_bar(position = "dodge")
```

Kun y-akselille asetetaan osuudet "y=..prop..", tulee funktiolle myös kertoa, mille ryhmille osuuksia (summautuu 100%:iin) lasketaan. Koska osuudet piirretaan eri uskonnoille, uskonto on ryhmitteleva tekija.

```{r}
p <- ggplot(gss_sm, mapping = aes(bigregion, fill = religion))
p + geom_bar(position = "dodge", mapping = aes(y=..prop..,group=religion))
```

Kuvaajassa alkaa olla jo liikaa tietoa. Sen voi palastella ruudukon (facet) avulla helpommin tarkasteltaviksi kuvaajiksi.

```{r}
p <- ggplot(gss_sm, mapping = aes(religion))
p + geom_bar(position = "dodge", mapping = aes(y=..prop.., group = bigregion)) + facet_wrap(~bigregion)
```

### Histograms and density plots

Histogrammi kuvaa jatkuvia muuttujia. (Pylvaskuvaajalla kuvataan luokittelevia muuttuja.) Histogrammiin maaritetaan "bin", eli jakso, tai "sailö", jonka sisaan osuvia havaintoja rtarkastellaan. Bin:in lukumaara (eli koko) vaikuttaa datasta tehtyyn kuvaajiin.

```{r}
p <- ggplot(midwest, mapping = aes(x=area))
p + geom_histogram()
```

```{r}
p <- ggplot(midwest, mapping = aes(x=area))
p + geom_histogram(bins = 10)
```

Fasettien lisaksi histogrammeja voi esittaa useamman kerralla piirtamalla niita paallekkain.

```{r}
oh_wi <- c("OH", "WI")

p <- ggplot(data = subset(midwest, subset = state %in% oh_wi),
            mapping = aes(x = percollege, fill = state))
p + geom_histogram(alpha = 0.4, bins = 20)
```

### Tiheysfunktio

Toinen mielekas tapa kuvata jatkuvia muuttujia on tiheysfunktio. Wikipedia: "Tiheysfunktioiden arvot eivat itsessaan ole todennaköisyyksia, mutta tiheysfunktion avulla voidaan laskea todennaköisyydet kayttamalla maarattya integraalia. Tiheysfunktio maarittelee satunnaismuuttujan taysin, ja sen avulla voidaan maarittaa satunnaismuuttujan kaikki ominaisuudet." **Tiheysfunktion pinta-ala on 1**

```{r}
p <- ggplot(midwest, mapping = aes(x=area))
p + geom_density()
```

Vareilla saa kuvaajaan lisainformaatioita. Huom: **fill tayttaa, color maaraa reunat**

```{r}
p <- ggplot(midwest, mapping = aes(area, fill=state, color = state))
p + geom_density(alpha = 0.3)
```

Vastaavanlaisen kuvaajan saa myös geom_line:lla.

```{r}
p <- ggplot(midwest, mapping = aes(x=area,  color = state))
p + geom_line(stat = "density")
```

```{r}
p <- ggplot(data = subset(midwest, subset = state %in% oh_wi),
            mapping = aes(x = area, fill = state, color = state))
p + geom_density(alpha = 0.3, mapping = (aes(y = ..scaled..)))
```

Usein data on jo valmiiksi koostetaulukko. Sillon kannattaa kayttaa geom_col:ia, joka vastaa geom_bar:ia, mutta jossa oletuksen a on stat = "identity", eli joka *ei laske datalla*

```{r}
glimpse(oecd_sum)
```


```{r}
p <- ggplot(data = oecd_sum,
            mapping = aes(x = year, y = diff, fill = hi_lo))
p + geom_col() + guides(fill = FALSE) +
  labs(x = NULL, y = "Difference in Years",
       title = "The US Life Expectancy Gap",
       subtitle = "Difference between US and OECD average life expectancies, 1960-2015",
       caption = "Data: OECD. After a chart by Christopher Ingraham,
                  Washington Post, December 27th 2017.")
```

## Graph Tables, Make Labels, Add Notes

Muokataan dataa itse, fokuksessa dplyr ja %>% 

Tehdaan gss_sm:sta uusi data

```{r}
rel_by_region <- gss_sm %>%
    group_by(bigregion, religion) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N),
           pct = round((freq*100), 0))

head(gss_sm)
head(rel_by_region)
```
Huomaa, etta group_by ottaa kaksi saraketta muuttujaksi! Sarake pct perustuu freq:iin.

Jokaisessa bigregion-ryhmassa uskontojen osuudet summautuvat noin sataan (huom. pyöristys aikaisemmin.)

```{r}
rel_by_region %>% group_by(bigregion) %>% summarize(total = sum(pct))
```

```{r}
p <- ggplot(rel_by_region, aes(bigregion, pct, fill = religion))
p + geom_col(position = "dodge")
```
```{r}
p <- ggplot(rel_by_region, aes(bigregion, pct, fill = religion))
p + geom_col(position = "dodge2") + 
  labs(x = "Alue", y = "Osuus", fill= "Uskonto") + theme(legend.position = "top")
```

Kuvaaja on sinansa hyva, mutta siina on liikaa informaatiota. *As a rule, dodged charts can be more cleanly expressed as faceted plots.*

Huomaa, etta nyt x-muuttuja vaihtuu

```{r}
p <- ggplot(rel_by_region, aes(religion, pct, fill = religion))
p + geom_col(position = "dodge2") + 
  labs(x = "Alue", y = "Osuus", fill= "Uskonto") + facet_grid(~bigregion) + coord_flip()+ guides(fill = F)
```

### Puuttuvat arvot datassa

```{r}
p <- ggplot(organdata, mapping = aes(year, donors))
p + geom_line() + facet_wrap(~country)
```
Boxplot kuvaa hajontaa

```{r}
p <- ggplot(organdata, mapping = aes(x=country, y=donors))
p+geom_boxplot() + coord_flip()
```

Kaytetaan **reorder-funktiota** kuvaajan jarjestamiseen. Reorder ottaa kaksi arkumenttia, jarjestettavan asian  ja muuttujan, jolla data jarjestetaan. Oletusarvoisesti jarjestamiseen kaytetaan muuttujan keskiarvoa. Myös muita funktioita voi kayttaa, esim. median tai sd. 

Huomaa, etta reorderille pitaa erikseen sanoa NA:iden poistamisesta!

**We are reordering the variable we are mapping to the x aesthetic, so we use reorder() at that point in our code**

```{r}
p <- ggplot(organdata, mapping = aes(x= reorder(country, donors, na.rm = T), y=donors))

p+geom_boxplot() + coord_flip() + labs(x=NULL)
```


```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = reorder(country, donors, na.rm=TRUE),
                          y = donors, fill = world))
p + geom_boxplot() + labs(x=NULL) +
    coord_flip() + theme(legend.position = "top")
```

Jos havaintoja on vahan, boxplotin voi korvata pistekuvaajalla (kirjoittajan mukaan)

```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = reorder(country, donors, na.rm=TRUE),
                          y = donors, color = world))
p + geom_jitter(position = position_jitter(width=0.15)) + labs(x=NULL) +
    coord_flip() + theme(legend.position = "top")
```

### Cleveland dotplot

Kirjoittajan mukaan parempi kuin pylvasdiagrammi tai taulukko(!) kun halutaan esittaa summatason tuloksia luokittelumuuttujasta. esim. keskiarvo, keskihajonta.

```{r}
by_country <- organdata %>% group_by(consent_law, country) %>%
    summarize(donors_mean= mean(donors, na.rm = TRUE),
              donors_sd = sd(donors, na.rm = TRUE),
              gdp_mean = mean(gdp, na.rm = TRUE),
              health_mean = mean(health, na.rm = TRUE),
              roads_mean = mean(roads, na.rm = TRUE),
              cerebvas_mean = mean(cerebvas, na.rm = TRUE))

head(by_country)
```

Datan luovassa koodissa on toistoa. sen voi poistaa *apply*-tyylisella rarkaisulla: 

```{r}
by_country <- organdata %>% group_by(consent_law, country) %>% summarize_if(is.numeric, list(mean, sd), na.rm=T) %>% ungroup
```
"In the last step in the pipeline we ungroup() the data, so that the result is a plain tibble. Sometimes graphing functions can get confused by grouped tibbles where we don’t explicitly use the groups in the plot."

```{r}
p <- ggplot(by_country, mapping = aes(x= donors_fn1, y=reorder(country, donors_fn1), color = consent_law))
p + geom_point() + labs(y = NULL, x= "Elinluovuttajien keskiarvo", color = "Laki") + theme(legend.position = "top")
```

```{r}
p <- ggplot(data = by_country,
            mapping = aes(x = donors_fn1,
                          y = reorder(country, donors_fn1)))

p + geom_point(size=3) +
    facet_wrap(~ consent_law, scales = "free_y", ncol = 1) +
    labs(x= "Donor Procurement Rate",
         y= "") 
```

**Cleveland dotplots are generally preferred to bar or column charts. When making them, put the categories on the y-axis and order them in the way that is most relevant to the numerical summary you are providing.** This sort of plot is also an excellent way to summarize model results or any data with with error ranges.

Boxplotia yksinkertasempi tapa esittaa keskiarvo ja keskihajonta on geom_pointrange, johon saadaan vaihteluvali.

```{r}
p <- ggplot(by_country, mapping=aes(x = reorder(country, donors_fn1), y=donors_fn1))

p + geom_pointrange(mapping = aes(ymin=donors_fn1 - donors_fn2, ymax= donors_fn1 + donors_fn2)) + coord_flip() + labs(x=NULL, y = "elinluovuttajat")
  
```

Kuvaajia voi piirtaa paallekkain. Alla esimerkissa geom_point ja geom_text

```{r}
p <- ggplot(by_country, aes(roads_fn1, donors_fn1))

p + geom_point() + geom_text(aes(label = country))
```

```{r}
p <- ggplot(by_country, aes(roads_fn1, donors_fn1))

p + geom_point() + geom_text(aes(label = country), hjust=0)
```

geom_text on oikeastan melko huono tekstin piirtaja, parempi on geom_text_repel. Se huolehtii siita, etta tekstit eivat tule paallekkain.


```{r}
library(ggrepel)
```

```{r, fig.height=12, fig.width=16}
elections_historic %>% select(2:7)

p_title <- "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <- "1824-2016"
p_caption <- "Data for 2016 are provisional."
x_label <- "Winner's share of Popular Vote"
y_label <- "Winner's share of Electoral College Votes"

p <- ggplot(elections_historic, aes(popular_pct, ec_pct, label = winner_label))

p + geom_hline(yintercept = 0.5, size = 1.4, color = "gray") + geom_vline(xintercept = 0.5, sixe = 1.4, color = "gray") + geom_point() + geom_text_repel() + scale_x_continuous(labels = scales::percent_format(accuracy = 1)) + scale_y_continuous(labels = scales::percent_format(accuracy = 1)) + labs(x = x_label, y = y_label, title = p_title, subtitle = p_subtitle,
         caption = p_caption)
```

Samaan kuvaan voi piirtaa myös geomeja, jotka kayttavat eri dataa, tao eri osia datasta

```{r}
p <- ggplot(by_country, aes(gdp_fn1, health_fn1))

p + geom_point() + geom_text_repel(data = subset(by_country, gdp_fn1>25000), mapping = aes(label = country))
```

```{r}
p <- ggplot(data = by_country,
            mapping = aes(x = gdp_fn1, y = health_fn1))

p + geom_point() +
    geom_text_repel(data = subset(by_country,
                                  gdp_fn1 > 25000 | health_fn1 < 1500 |
                                  country %in% "Belgium"),
                    mapping = aes(label = country))
```

Dataan voi myös luoda dummymuuttujan, jonka avulla kuvaajaan lisataan tietoa

```{r}
organdata$ind <- organdata$ccode %in% c("Ita", "Spa") 

p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors, color = ind))
p + geom_point() + geom_text_repel(data = subset(organdata, ind), aes(label = ccode)) + guides(label = F, color = F)
```

"annotate" mahdollistaa tekstin ja muiden lisamerkintöjen laittamisen kuvaajaan. Se hyödyntaa geom_text:ia ja muita geomeita.

```{r}
p <- ggplot(data = organdata, mapping = aes(x = roads, y = donors))
p + geom_point() + annotate(geom = "text", x = 91, y = 33,
                            label = "A surprisingly high \n recovery rate.",
                            hjust = 0)
```

```{r}
p <- ggplot(organdata, aes(roads, donors))

p + geom_point() + annotate(geom = "rect", xmin=125, xmax=155, ymin=30, ymax=35, fill="orange", alpha = 0.3) + annotate(geom= "text", x = 157, y= 33, label= "Yllattavan korkea \n selviytymisaste", hjust = 0)
```

**What are the differences between the scale_ functions, the guides() function, and the theme() function?**

Here is a rough and ready starting point:

    - **Every aesthetic mapping has a scale**. If you want to adjust how that scale is marked or graduated, then you use a scale_ function.
    - Many scales come with a legend or key to help the reader interpret the graph. These are called guides. You can make adjustments to them with the guides() function. Perhaps the most common use case is to make the legend disappear, as it is sometimes superfluous. Another is to adjust the arrangement of the key in legends and colorbars.
    - Graphs have other features not strictly connected to the logical structure of the data being displayed. These include things like their background color, the typeface used for labels, or the placement of the legend on the graph. To adjust these, use the theme() function.

```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors,
                          color = world))
p + geom_point()
```

Kuvaajaa ylla "shows a plot with three aesthetic mappings. The variable roads is mapped to x; donors is mapped to y; and world is mapped to color." --> **kolme muuttujaa, kolme asteikkoa!**

Asteikkoja(akseleita) voi saataa:

```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors,
                          color = world))
p + geom_point() +
    scale_x_log10() +
    scale_y_continuous(breaks = c(5, 15, 25),
                       labels = c("Five", "Fifteen", "Twenty Five"))
```

Myös vari- ja muotoasteikkoja voi saataa

```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors,
                          color = world))
p + geom_point() +
    scale_color_discrete(labels =
                             c("Corporatist", "Liberal",
                               "Social Democratic", "Unclassified")) +
    labs(x = "Road Deaths",
         y = "Donor Procurement",
        color = "Welfare State")
```

## Work with Models

The geom_smooth() function can take a range of method arguments to fit LOESS, OLS, and robust regression lines, amongst others.

- MASS library’s rlm function to fit a robust regression line
- In the second panel, the bs function is invoked directly from the splines library in the same way, to fit a polynominal curve to the data
-  The geom_quantile() function, meanwhile, is like a specialized version of geom_smooth() that can fit quantile regression lines using a variety of methods. The quantiles argument takes a vector specifying the quantiles at which to fit the lines.

```{r}
p <- ggplot(gapminder, aes(x = log(gdpPercap), y = lifeExp))

p + geom_point(alpha=0.1) + geom_smooth(color = "tomato", fill = " tomato", method = MASS::rlm) + geom_smooth(color = "blue", fill="blue", method = "lm")

p + geom_point(alpha=0.1) +
    geom_smooth(color = "purple", method = "lm", size = 1.2, 
                formula = y ~ splines::bs(x, 3), se = FALSE)

p + geom_point(alpha=0.1) +
    geom_quantile(color = "green", size = 1.2, method = "rqss",
                  lambda = 1, quantiles = c(0.20, 0.5, 0.85))
```

Malleja voi sovittaa useamman kuvaajaan ja lisata niille legendat

```{r}
model_colors <- RColorBrewer::brewer.pal(3, "Set1")
model_colors

p0 <- ggplot(data = gapminder,
            mapping = aes(x = log(gdpPercap), y = lifeExp))

p1 <- p0 + geom_point(alpha = 0.2) +
    geom_smooth(method = "lm", aes(color = "OLS", fill = "OLS")) +
    geom_smooth(method = "lm", formula = y ~ splines::bs(x, df = 3),
                aes(color = "Cubic Spline", fill = "Cubic Spline")) +
    geom_smooth(method = "loess",
                aes(color = "LOESS", fill = "LOESS"))


p1 + scale_color_manual(name = "Models", values = model_colors) +
    scale_fill_manual(name = "Models", values = model_colors) +
    theme(legend.position = "top")
```

#### Look inside model objects

We can create a linear model, an ordinary OLS regression, using the gapminder data. This dataset has a country-year structure that makes an OLS specification like this the wrong one to use **(MIKSI?)**. But never mind that for now. We use the lm() function to run the model, and store it in an object called out:

```{r}
out <- lm(formula = lifeExp ~ gdpPercap + pop + continent,
          data = gapminder)

summary(out)
```

**When we use the summary() function on out, we are not getting a simple feed of what’s in the model object.** Instead, like any function, summary() takes its input, performs some actions, and produces output. In this case, what is printed to the console is partly information that is stored inside the model object, and partly information that the summary() function has calculated and formated for display on the screen. Behind the scenes, summary() gets help from other functions. Objects of different classes have default methods associated with them, so that when the generic summary() function is applied to a linear model object, the function knows to pass the work on to a more specialized function that does a bunch of calculations and formatting appropriate to a linear model object. 

**str() paljastaa rakenteen** mutta objektin elementitkin voivat olla listoja.

```{r}
names(out)
str(out)
```


#### Get model-based graphics right

Figures based on statistical models face all the ordinary challenges of effective data visualization, and then some. This is because **model results usually carry a considerable extra burden of interpretation and necessary background knowledge.** The more complex the model, the trickier it becomes to convey this information effectively, and the easier it becomes to lead one’s audience or oneself into error.

Some kinds of models are quite tricky to understand, even ones that had previously been seen as straightforward elements of the modeling toolkit (Ai & Norton, 2003; Brambor, Clark, & Golder, 2006).

Plotting model estimates is closely connected to properly estimating models in the first place. This means **there is no substitute for learning the statistics. You should not use graphical methods as a substitute for understanding the model used to produce them.**

#### Present your findings in substantive terms

Presenting substantively interpretable findings often also means using (and sometimes converting to) a scale that readers can easily understand. If your model reports **results in log-odds**, for example, converting the estimates **to predicted probabilities** will make it easier to interpret.

#### Show your degree of confidence

Model estimates come with various measures of precision, confidence, credence, or significance. Presenting and interpreting these measures is notoriously prone to misinterpretation, or over-interpretation, as researchers and audiences both demand more from things like confidence intervals and p-values than these statistics can deliver. At a minimum, having decided on an appropriate measure of model fit or the right assessment of confidence, you should show their range when you present your results. A family of related ggplot geoms allow you to show a range or interval defined by position on the x-axis and then a ymin and ymax range on the y-axis. These geoms include **geom_pointrange()** and **geom_errorbar()**, which we will see in action shortly. A related geom, geom_ribbon() uses the same arguments to draw filled areas, and is useful for plotting ranges of y-axis values along some continuously varying x-axis.

#### Show your data when you can

The way ggplot builds graphics layer by layer allows us to easily combine model estimates (e.g. a regression line and an associated range) and the underlying data. 

### 6.4 Generate predictions to graph

Having fitted a model, then, we might want to get a picture of the estimates it produces over the range of some particular variable, holding other covariates constant at some sensible values. The **predict()** function is a generic way of using model objects to produce this kind of prediction. Geneerinen funktio = toimii erilaisille tietorakenteille, antaa jokaiselle sovitetun tulosteen. Esim. summary, str, ja predict.

For predict() to calculate the new values for us, it needs some new data to fit the model to.  A very useful function called **expand.grid()** will help us do this. We will give it a list of variables, specifying the range of values we want each variable to take. Then expand.grid() will generate the will multiply out the full range of values for all combinations of the values we give it.









### 6.7 Plot marginal effects

Over the past decade, estimating and plotting partial or marginal effects from a model has become an increasingly common way of presenting accurate and interpretively useful predictions. Interest in marginal effects plots was stimulated by the realization that the interpretation of terms in logistic regression models, in particular, was trickier than it seemed.

Marginal effect (=Rajavaikutus) voidaan piirtaa Thomas Leeprein "margins"-paketin avulla. Logistinen regressio tehdaan gss_sm-dataan. Alla omia tarkasteluja mallin muuttujiin

```{r, logistinen regressio, oma 1}
muuttujat <- select(gss_sm, obama, sex, race, polviews)
str(muuttujat)
```
Huom! Muuttujat faktoreita! Referenssiarvoksi valikoituu faktorin ensimmainen taso, jos toisin ei maarieta. Muuttujalle polviews tehdaan niin:

```{r, logistinen regressio, oma 2}
muuttujat$polviews_m <- relevel(gss_sm$polviews, ref = "Moderate")
str(muuttujat)
```

Palataan kirjan koodiin:

"We fit the model with the glm() function, and specify an **interaction** between race and sex."

"Tilastollinen interaktio tarkoittaa, etta emme voi tarkastella pelkastaan tekijöiden paavaikutuksia erillisina, vaan meidan on otettava huomioon myös muiden tekijöiden vaikutus yhta tekijaa tarkastellessamme" <http://cc.oulu.fi/~jarioksa/opetus/rekola/html-opas/node58.html>

Muuttujat voivat siis tehostaa tai heikentaa toistensa vaikutusta vastemuuttujaan, mika pitaisi huomioida mallissa!

Interaktioita voi etsia pairs-kuvaajalla, tai paatöspuulla
```{r, logistinen regressio, oma 3}
pairs(muuttujat)
# ei toimi kovin hyvin kun muuttujat ovat diskreetteja!!!
```
```{r}
library(tree)
fit <- tree(obama~., data = muuttujat)
summary(fit)
plot(fit)
text(fit, splits = TRUE)
# interaktioiden tutkimiseeen: http://www3.imperial.ac.uk/pls/portallive/docs/1/1171924.PDF
```
```{r}
fit2 <- tree(obama~., data = subset(gss_sm, select = -pres12))
summary(fit2)
plot(fit2)
text(fit2)
```


```{r}
gss_sm$polviews_m <- relevel(gss_sm$polviews, ref = "Moderate")

out_bo <- glm(obama ~ polviews_m + sex*race, family = binomial, data = gss_sm)

summary(out_bo)
```

Lasketaan muuttujien rajavaikutukset
```{r}
bo_m <- margins::margins(out_bo)
summary(bo_m)
```

## Draw Maps

```{r}

```


## Refine your Plots

```{r}

```


