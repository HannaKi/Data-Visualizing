---
title: "Data Visualization Notes"
author: "Kieran Healy"
date: "2019-01-02"
output: html_document
---
   
## Data Visualization Notes

This is a starter RMarkdown template to accompany *Data Visualization* (Princeton University Press, 2019). You can use it to take notes, write your code, and produce a good-looking, reproducible document that records the work you have done. At the very top of the file is a section of *metadata*, or information about what the file is and what it does. The metadata is delimited by three dashes at the start and another three at the end. You should change the title, author, and date to the values that suit you. Keep the `output` line as it is for now, however. Each line in the metadata has a structure. First the *key* ("title", "author", etc), then a colon, and then the *value* associated with the key.  

## This is an RMarkdown File

Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. A *code chunk* is a specially delimited section of the file. You can add one by moving the cursor to a blank line choosing Code > Insert Chunk from the RStudio menu. When you do, an empty chunk will appear:

```{r}
## Onpa hienoa!

```

```{r}

```

Code chunks are delimited by three backticks (found to the left of the 1 key on US and UK keyboards) at the start and end. The opening backticks also have a pair of braces and the letter `r`, to indicate what language the chunk is written in. You write your code inside the code chunks. Write your notes and other material around them, as here. 

## Before you Begin

To install the tidyverse, make sure you have an Internet connection. Then *manually* run the code in the chunk below. If you knit the document if will be skipped. We do this because you only need to install these packages once, not every time you run this file. Either knit the chunk using the little green "play" arrow to the right of the chunk area, or copy and paste the text into the console window.

```{r install, eval = FALSE}

## This code will not be evaluated automatically.
## (Notice the eval = FALSE declaration in the options section of the
## code chunk)

my_packages <- c("tidyverse", "broom", "coefplot", "cowplot",
                 "gapminder", "GGally", "ggrepel", "ggridges", "gridExtra",
                 "here", "interplot", "margins", "maps", "mapproj",
                 "mapdata", "MASS", "quantreg", "rlang", "scales",
                 "survey", "srvyr", "viridis", "viridisLite", "devtools")

install.packages(my_packages, repos = "http://cran.rstudio.com")

```

## Set Up Your Project and Load Libraries

To begin we must load some libraries we will be using. If we do not load them, R will not be able to find the functions contained in these libraries. The tidyverse includes ggplot and other tools. We also load the socviz and gapminder libraries.

```{r setup, include=FALSE}

## By defult, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(echo = TRUE) 

## Set the default size of figures
knitr::opts_chunk$set(fig.width=8, fig.height=5)  

## Load the libraries we will be using
library(gapminder)
library(here)
library(socviz)
library(tidyverse)

```

Notice that here, the braces at the start of the code chunk have some additional options set in them. There is the language, `r`, as before. This is required. Then there is the word `setup`, which is a label for your code chunk. Labels are useful to briefly say what the chunk does. Label names must be unique (no two chunks in the same document can have the same label) and cannot contain spaces. Then, after the comma, an option is set: `include=FALSE`. This tells R to run this code but not to include the output in the final document. 
```{r}
# eli edellisen kappaleen yläpuolella on
# koodia, jota ei tulosteta html-tiedostoon
```


When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r look}
gapminder
```

The remainder of this document contains the chapter headings for the book, and an empty code chunk in each section to get you started. Try knitting this document now by clicking the "Knit" button in the RStudio toolbar, or choosing File > Knit Document from the RStudio menu.

## Look at Data

```{r}

```


## Get Started

Muistiinpanoja: 

- "it’s better to think of the data and code as what’s real, together with the text you write."

- "The reality for most of us is that the person who will most want to easily reproduce your work is you, six months or a year from now."

- "While a script file can keep comments and code together, it loses *the connection between code and its output*, such as the figure we want to produce. But there is a better alternative: we can write our notes using RMarkdown."

```{r}
# Ctrl+Alt+I Windowsilla antaa tällaisen koodipalan. (Entä Linux?)
```


```{r}

```


## Make a Plot

```{r}
summary(gapminder)
```


Katsotaan datan muuttujien nimet

```{r}
colnames(gapminder)
```

Niistä saadaan elementit kuvaajan piirtämiseen

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp,
                          size = pop,
                          color = continent)) +
                          geom_point() +
                          coord_cartesian() +
                          scale_x_log10() +
                          labs(x = "log GDP", y = "Life expectancy",
                          title = "kuvaaja")

# piirrä tulostamalla "p"
p
```


"An aesthetic mapping **aes** specifies that a **variable** will be expressed by one of the available visual elements, such as size, or color, or shape, and so on."

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp,
                          color = "purple"))+
  geom_point() +
    geom_smooth(method = "loess") +
    scale_x_log10() + 
    labs(title = "aes-funktioon annettu värimäärittely VÄÄRIN.", subtitle = "ggplotille annetaan vain datan muutujia, nyt se on luonut kokonaan uuden muuttujan, 'purple'")

p

```

"The aes() function is for mappings only. Do not use it to change properties to a particular value."!!!

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp))
p + geom_point(color = "purple") +
    geom_smooth(method = "loess") +
    scale_x_log10() + 
    labs(title = "Värin voi määrittää geom-funktiolle mutta se ei tuo tässä lisää tietoa")
```

ggplot koostuu kerroksista, jossa jokainen kerroksen funktio voi käyttää omia parametrejaan:

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp)) 
p + geom_point(alpha = 0.3) +
    geom_smooth(color = "orange", se = FALSE, size = 8, method = "lm") +
    scale_x_log10()
```

- "'alpha' is an aesthetic property that points (and some other plot elements) have, and to which variables can be mapped"

- Choosing an intermediate alpha-value can be useful when there is a lot of overlapping data to plot

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y=lifeExp))

p+  geom_point(alpha = 0.3) +
    geom_smooth(method = "gam") +
    scale_x_log10(labels = scales::dollar) +
    labs(x = "GDP Per Capita", y = "Life Expectancy in Years",
         title = "Economic Growth and Life Expectancy",
         subtitle = "Data points are country-years",
         caption = "Source: Gapminder.")
```

Huomaa kuvaajassa yllä hieno otsikointi ja lähdeviitteet, jotka on tehty labs-funktiolla. Akselien asteikon $-merkki tulee kuitenkin scale-funktion parametrina

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp,
                          color = continent,
                          fill = continent))
p + geom_point() +
    geom_smooth(method = "loess") +
    scale_x_log10()
```
- Kun ggplotille annetaan piirrettäväksi uusi muuttuja, muuttuja "periytyy" kaikille lisämäärittelyjä tekeville funktioille. Siksi kaikille conitnent-muuttujille tulee oma regressiokäyrä. 

- huomaa fill, joka värittää täytettävissä olevat alat

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_point(mapping = aes(color = continent)) +
    geom_smooth(method = "loess") +
    scale_x_log10()
```

Jos geom_funktiolle määrittää erikseen, mitä muuttujia sen avulla haluaa piirtää, periytymistä voi rajoittaa.

Myös jatkuva muuttuja voi määrätä värin

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp))
p + geom_point(mapping = aes(color = log(pop))) +
    scale_x_log10()
```

Kuvaajan tallenteminen toimii here-funktion avulla

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp)) +
    geom_point(mapping = aes(color = log(pop))) +
    scale_x_log10()

ggsave(here("output", "figures", "testikuvaaja.png"), plot = p)
```

### Kokeiluja 

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_point(mapping = aes(color = continent)) +
    geom_smooth(method = "loess") +
    scale_x_log10() + 
    labs(title = "Alkuperäinen kuvaaja")
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_x_log10() + 
    labs(title = "geom_smooth ennen geom_pointia")
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = pop, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_x_log10() + 
    labs(title = "Elinaika suhteessa populaatioon")
```
Tulkinta: Elinajanennuste on alhaisin Afrikassa. Elinajanennuste on keskimäärin hieman korkeampi maissa, joissa on suuri väestö.

Kokeiluja akseleilla

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_y_log10() 
```

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_x_sqrt() 
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_x_reverse() 
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) 
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = year)) +
    scale_x_log10() + 
    labs(title="värimääreenä vuosi eikä manner")
```
```{r}
p <- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = factor(year))) +
    scale_x_log10() + 
    labs(title="värimääreenä vuosi eikä manner HUOM! factor(year)!!!!")
```

```{r}
gapminder2 <- filter(gapminder, year == 2007)
p <- ggplot(data = gapminder2, mapping = aes(x = gdpPercap, y = lifeExp))
p + geom_smooth(method = "loess") +
    geom_point(mapping = aes(color = continent)) +
    scale_x_log10() 
```


## Show the Right Numbers

Allaolevassa kuvaajassa, jossa piirretään kahta jatkuvaa muuttujaa, muuttujissa itsessään ei ole ryhmittelyä (kuten manner tai maa). Tämän vuoksi ggplotille kerrotaan, että jokainen vuosi kuuluu jollekkin maalle, eli aes(group=country). Näin jokaiselle maalle piirtyy oma viivansa.

```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = year,
                          y = gdpPercap))
p + geom_line(aes(group=country)) 
```

### Ruudukot tiedon esittämisen apuna

Fasetilla voidaan jakaa kuva useampaan ruutuun luokittelevan muuttujan perusteella. Kuvat listautuvat peräkkäin, tai voit määrittää, montako kuvaa haluat rinnakkain.

```{r}
p <- ggplot(data = gapminder, mapping = aes(x = year, y = gdpPercap))

p + geom_line(aes(group = country)) + facet_wrap(~ continent)
```

```{r}
p <- ggplot(gapminder, aes(year, gdpPercap)) + geom_line(color = "gray", aes(group = country)) + geom_smooth(method = loess, se = F) + scale_y_log10(labels=scales::dollar) + facet_wrap(~ continent, ncol = 5) + labs(x= "vuosi", y = "BKT/hlö", title="BKT henkilöä kohden viidellä mantereella") 

# + theme(axis.title.x = element_text(angle = 90, vjust = 0.25))
# Miten muokataan fasettien akseleita?
p

ggsave(here("output", "figures", "BKT_per_hlo_mantereittain.jpg"), plot = p)
```
```{r}
p <- ggplot(data = gapminder,
            mapping = aes(x = gdpPercap,
                          y = lifeExp)) 
p + geom_point(alpha = 0.3) +
    geom_smooth(color = "orange", se = FALSE, method = "lm") +
    scale_x_log10()+facet_wrap(~continent)
```
### Siirrytään dataan, jossa luokittelevia muuttujia

gss_sm on yhteiskuntatieteellisen tutkimuksen dataa. Muuttujista moni on *luokitteleva* tai *järjestysasteikollinen*

-  because we are *cross-classifying* our results, the formula is two-sided: *facet_grid(sex ~ race)*.

```{r}
p <- ggplot(data = gss_sm, aes(age, childs))
p + geom_point(alpha = 0.2)+geom_smooth()+facet_grid(sex~race)
```
Ruudukkoon voi ottaa useamman tekijän, mutta tulkitseminen menee hankalaksi eikä datakaan välttämättä enää riitä.

```{r}
p <- ggplot(data = gss_sm, aes(age, childs))
p + geom_point(alpha = 0.2)+geom_smooth()+facet_grid(sex~race~obama)
```

### Pylväsdiagrammi

Pylväskuvaajalla kuvataan luokittelevia muuttujia.

Jokaiseen geom_-funktioon liittyy stat_funktio, joka tulee kutsustuksi automaattisesti, ellei toisin määritetä.

Pylväsdiagrammille stat on count, eli määrä, jonka funktio laskee datasta kuvaajalle "lennosta".

```{r}
p <- ggplot(gss_sm, aes(x=bigregion))
p + geom_bar(mapping = aes(fill=bigregion))
```
Jos kuvaajaan halutaan muutujan arvojen osuudet, tulee käyttää toista geom_bar:in stat-funktiota, ..prop..:ia. Huomaa erikoinen merkintä!

Lisäksi funktiokutsulle on määriettävä, että sen ei tule jakaa dataa osiin x-akselille, vaan x-akselin arvot summautuvat yhteen. 

```{r}
p <- ggplot(gss_sm, aes(x=bigregion))
p + geom_bar(mapping = aes(y = ..prop.., fill=bigregion)) + labs(title="Tässä muuttuja ei summaudu yhteen", subtitle = "Vaan jokainen arvo summautuu yhteen")
```

Muuttuja saadaan summautumaan yhteen dummy-muuttujalla, group = 1.

```{r}
p <- ggplot(gss_sm, aes(bigregion))
p + geom_bar(color= "blue", fill= "orange", mapping = aes(y=..prop.., group=1))
```
Huomaa, fill=bigregion ei enää, toimi, koska muuttujassa ei ole enää useampaa luokkaa, vaan yksi dummy!

### Frequency plots the slightly awkward way

fill-parametrin paras käyttökohde on kolmannen muuttujan tuominen kuvaajaan värittämällä kaavion pylväät sen mukaan

```{r}
p <- ggplot(gss_sm, mapping = aes(bigregion, fill = religion))
p + geom_bar()
```

Pinottu pylväs on pylväsdiagrammin oletus. Tätä voidaan muuttaa "position"-argumentilla

```{r}
p <- ggplot(gss_sm, mapping = aes(bigregion, fill = religion))
p + geom_bar(position = "fill")
```
Vertailu ryhmien sisällä on näin helppoa, mutta ryhmien kesken vaikeaa. "dodge" asettaa pylväät rinnakkain, mutta sellaisenaan se antaa datan lukumäärät

```{r}
p <- ggplot(gss_sm, mapping = aes(bigregion, fill = religion))
p + geom_bar(position = "dodge")
```

Kun y-akselille asetetaan osuudet "y=..prop..", tulee funktiolle myös kertoa, mille ryhmille osuuksia (summautuu 100%:iin) lasketaan. Koska osuudet piirretään eri uskonnoille, uskonto on ryhmittelevä tekijä.

```{r}
p <- ggplot(gss_sm, mapping = aes(bigregion, fill = religion))
p + geom_bar(position = "dodge", mapping = aes(y=..prop..,group=religion))
```

Kuvaajassa alkaa olla jo liikaa tietoa. Sen voi palastella ruudukon (facet) avulla helpommin tarkasteltaviksi kuvaajiksi.

```{r}
p <- ggplot(gss_sm, mapping = aes(religion))
p + geom_bar(position = "dodge", mapping = aes(y=..prop.., group = bigregion)) + facet_wrap(~bigregion)
```

### Histograms and density plots

Histogrammi kuvaa jatkuvia muuttujia. (Pylväskuvaajalla kuvataan luokittelevia muuttuja.) Histogrammiin määritetään "bin", eli jakso, tai "säilö", jonka sisään osuvia havaintoja rtarkastellaan. Bin:in lukumäärä (eli koko) vaikuttaa datasta tehtyyn kuvaajiin.

```{r}
p <- ggplot(midwest, mapping = aes(x=area))
p + geom_histogram()
```

```{r}
p <- ggplot(midwest, mapping = aes(x=area))
p + geom_histogram(bins = 10)
```

Fasettien lisäksi histogrammeja voi esittää useamman kerralla piirtämällä niitä päällekkäin.

```{r}
oh_wi <- c("OH", "WI")

p <- ggplot(data = subset(midwest, subset = state %in% oh_wi),
            mapping = aes(x = percollege, fill = state))
p + geom_histogram(alpha = 0.4, bins = 20)
```

### Tiheysfunktio

Toinen mielekäs tapa kuvata jatkuvia muuttujia on tiheysfunktio. Wikipedia: "Tiheysfunktioiden arvot eivät itsessään ole todennäköisyyksiä, mutta tiheysfunktion avulla voidaan laskea todennäköisyydet käyttämällä määrättyä integraalia. Tiheysfunktio määrittelee satunnaismuuttujan täysin, ja sen avulla voidaan määrittää satunnaismuuttujan kaikki ominaisuudet." **Tiheysfunktion pinta-ala on 1**

```{r}
p <- ggplot(midwest, mapping = aes(x=area))
p + geom_density()
```

Väreillä saa kuvaajaan lisäinformaatioita. Huom: **fill täyttää, color määrää reunat**

```{r}
p <- ggplot(midwest, mapping = aes(area, fill=state, color = state))
p + geom_density(alpha = 0.3)
```

Vastaavanlaisen kuvaajan saa myös geom_line:lla.

```{r}
p <- ggplot(midwest, mapping = aes(x=area,  color = state))
p + geom_line(stat = "density")
```

```{r}
p <- ggplot(data = subset(midwest, subset = state %in% oh_wi),
            mapping = aes(x = area, fill = state, color = state))
p + geom_density(alpha = 0.3, mapping = (aes(y = ..scaled..)))
```

Usein data on jo valmiiksi koostetaulukko. Sillon kannattaa käyttää geom_col:ia, joka vastaa geom_bar:ia, mutta jossa oletuksen a on stat = "identity", eli joka *ei laske datalla*

```{r}
glimpse(oecd_sum)
```


```{r}
p <- ggplot(data = oecd_sum,
            mapping = aes(x = year, y = diff, fill = hi_lo))
p + geom_col() + guides(fill = FALSE) +
  labs(x = NULL, y = "Difference in Years",
       title = "The US Life Expectancy Gap",
       subtitle = "Difference between US and OECD average life expectancies, 1960-2015",
       caption = "Data: OECD. After a chart by Christopher Ingraham,
                  Washington Post, December 27th 2017.")
```

## Graph Tables, Make Labels, Add Notes

Muokataan dataa itse, fokuksessa dplyr ja %>% 

Tehdään gss_sm:stä uusi data

```{r}
rel_by_region <- gss_sm %>%
    group_by(bigregion, religion) %>%
    summarize(N = n()) %>%
    mutate(freq = N / sum(N),
           pct = round((freq*100), 0))

head(gss_sm)
head(rel_by_region)
```
Huomaa, että group_by ottaa kaksi saraketta muuttujaksi! Sarake pct perustuu freq:iin.

Jokaisessa bigregion-ryhmässä uskontojen osuudet summautuvat noin sataan (huom. pyöristys aikaisemmin.)

```{r}
rel_by_region %>% group_by(bigregion) %>% summarize(total = sum(pct))
```

```{r}
p <- ggplot(rel_by_region, aes(bigregion, pct, fill = religion))
p + geom_col(position = "dodge")
```
```{r}
p <- ggplot(rel_by_region, aes(bigregion, pct, fill = religion))
p + geom_col(position = "dodge2") + 
  labs(x = "Alue", y = "Osuus", fill= "Uskonto") + theme(legend.position = "top")
```

Kvaaja on sinänsä hyvä, mutta siinä on liikaa informaatiota. *As a rule, dodged charts can be more cleanly expressed as faceted plots.*

Huomaa, että nyt x-muuttuja vaihtuu

```{r}
p <- ggplot(rel_by_region, aes(religion, pct, fill = religion))
p + geom_col(position = "dodge2") + 
  labs(x = "Alue", y = "Osuus", fill= "Uskonto") + facet_grid(~bigregion) + coord_flip()+ guides(fill = F)
```

### Puuttuvat arvot datassa

```{r}
p <- ggplot(organdata, mapping = aes(year, donors))
p + geom_line() + facet_wrap(~country)
```
Boxplot kuvaa hajontaa

```{r}
p <- ggplot(organdata, mapping = aes(x=country, y=donors))
p+geom_boxplot() + coord_flip()
```

Käytetään **reorder-funktiota** kuvaajan järjestämiseen. Reorder ottaa kaksi arkumenttia, järjestettävän asian  ja muuttujan, jolla data järjestetään. Oletusarvoisesti järjestämiseen käytetään muuttujan keskiarvoa. Myös muita funktioita voi käyttää, esim. median tai sd. 

Huomaa, että reorderille pitää erikseen sanoa NA:iden poistamisesta!

**We are reordering the variable we are mapping to the x aesthetic, so we use reorder() at that point in our code**

```{r}
p <- ggplot(organdata, mapping = aes(x= reorder(country, donors, na.rm = T), y=donors))

p+geom_boxplot() + coord_flip() + labs(x=NULL)
```


```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = reorder(country, donors, na.rm=TRUE),
                          y = donors, fill = world))
p + geom_boxplot() + labs(x=NULL) +
    coord_flip() + theme(legend.position = "top")
```

Jos havaintoja on vähän, boxplotin voi korvata pistekuvaajalla (kirjoittajan mukaan)

```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = reorder(country, donors, na.rm=TRUE),
                          y = donors, color = world))
p + geom_jitter(position = position_jitter(width=0.15)) + labs(x=NULL) +
    coord_flip() + theme(legend.position = "top")
```

### Cleveland dotplot

Kirjoittajan mukaan parempi kuin pylväsdiagrammi tai taulukko(!) kun halutaan esittää summatason tuloksia luokittelumuuttujasta. esim. keskiarvo, keskihajonta.

```{r}
by_country <- organdata %>% group_by(consent_law, country) %>%
    summarize(donors_mean= mean(donors, na.rm = TRUE),
              donors_sd = sd(donors, na.rm = TRUE),
              gdp_mean = mean(gdp, na.rm = TRUE),
              health_mean = mean(health, na.rm = TRUE),
              roads_mean = mean(roads, na.rm = TRUE),
              cerebvas_mean = mean(cerebvas, na.rm = TRUE))

head(by_country)
```

Datan luovassa koodissa on toistoa. sen voi poistaa *apply*-tyylisellä rarkaisulla: 

```{r}
by_country <- organdata %>% group_by(consent_law, country) %>% summarize_if(is.numeric, list(mean, sd), na.rm=T) %>% ungroup
```
"In the last step in the pipeline we ungroup() the data, so that the result is a plain tibble. Sometimes graphing functions can get confused by grouped tibbles where we don’t explicitly use the groups in the plot."

```{r}
p <- ggplot(by_country, mapping = aes(x= donors_fn1, y=reorder(country, donors_fn1), color = consent_law))
p + geom_point() + labs(y = NULL, x= "Elinluovuttajien keskiarvo", color = "Laki") + theme(legend.position = "top")
```

```{r}
p <- ggplot(data = by_country,
            mapping = aes(x = donors_fn1,
                          y = reorder(country, donors_fn1)))

p + geom_point(size=3) +
    facet_wrap(~ consent_law, scales = "free_y", ncol = 1) +
    labs(x= "Donor Procurement Rate",
         y= "") 
```

**Cleveland dotplots are generally preferred to bar or column charts. When making them, put the categories on the y-axis and order them in the way that is most relevant to the numerical summary you are providing.** This sort of plot is also an excellent way to summarize model results or any data with with error ranges.

Boxplotia yksinkertasempi tapa esittää keskiarvo ja keskihajonta on geom_pointrange, johon saadaan vaihteluväli.

```{r}
p <- ggplot(by_country, mapping=aes(x = reorder(country, donors_fn1), y=donors_fn1))

p + geom_pointrange(mapping = aes(ymin=donors_fn1 - donors_fn2, ymax= donors_fn1 + donors_fn2)) + coord_flip() + labs(x=NULL, y = "elinluovuttajat")
  
```

Kuvaajia voi piirtää päällekkäin. Alla esimerkissä geom_point ja geom_text

```{r}
p <- ggplot(by_country, aes(roads_fn1, donors_fn1))

p + geom_point() + geom_text(aes(label = country))
```

```{r}
p <- ggplot(by_country, aes(roads_fn1, donors_fn1))

p + geom_point() + geom_text(aes(label = country), hjust=0)
```

geom_text on oikeastan melko huono tekstin piirtäjä, parempi on geom_text_repel. Se huolehtii siitä, että tekstit eivät tule päällekkäin.


```{r}
library(ggrepel)
```

```{r, fig.height=12, fig.width=16}
elections_historic %>% select(2:7)

p_title <- "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <- "1824-2016"
p_caption <- "Data for 2016 are provisional."
x_label <- "Winner's share of Popular Vote"
y_label <- "Winner's share of Electoral College Votes"

p <- ggplot(elections_historic, aes(popular_pct, ec_pct, label = winner_label))

p + geom_hline(yintercept = 0.5, size = 1.4, color = "gray") + geom_vline(xintercept = 0.5, sixe = 1.4, color = "gray") + geom_point() + geom_text_repel() + scale_x_continuous(labels = scales::percent_format(accuracy = 1)) + scale_y_continuous(labels = scales::percent_format(accuracy = 1)) + labs(x = x_label, y = y_label, title = p_title, subtitle = p_subtitle,
         caption = p_caption)
```

Samaan kuvaan voi piirtää myös geomeja, jotka käyttävät eri dataa, tao eri osia datasta

```{r}
p <- ggplot(by_country, aes(gdp_fn1, health_fn1))

p + geom_point() + geom_text_repel(data = subset(by_country, gdp_fn1>25000), mapping = aes(label = country))
```

```{r}
p <- ggplot(data = by_country,
            mapping = aes(x = gdp_fn1, y = health_fn1))

p + geom_point() +
    geom_text_repel(data = subset(by_country,
                                  gdp_fn1 > 25000 | health_fn1 < 1500 |
                                  country %in% "Belgium"),
                    mapping = aes(label = country))
```

Dataan voi myös luoda dummymuuttujan, jonka avulla kuvaajaan lisätään tietoa

```{r}
organdata$ind <- organdata$ccode %in% c("Ita", "Spa") 

p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors, color = ind))
p + geom_point() + geom_text_repel(data = subset(organdata, ind), aes(label = ccode)) + guides(label = F, color = F)
```

"annotate" mahdollistaa tekstin ja muiden lisämerkintöjen laittamisen kuvaajaan. Se hyödyntää geom_text:iä ja muita geomeita.

```{r}
p <- ggplot(data = organdata, mapping = aes(x = roads, y = donors))
p + geom_point() + annotate(geom = "text", x = 91, y = 33,
                            label = "A surprisingly high \n recovery rate.",
                            hjust = 0)
```

```{r}
p <- ggplot(organdata, aes(roads, donors))

p + geom_point() + annotate(geom = "rect", xmin=125, xmax=155, ymin=30, ymax=35, fill="orange", alpha = 0.3) + annotate(geom= "text", x = 157, y= 33, label= "Yllättävän korkea \n selviytymisaste", hjust = 0)
```

**What are the differences between the scale_ functions, the guides() function, and the theme() function?**

Here is a rough and ready starting point:

    - **Every aesthetic mapping has a scale**. If you want to adjust how that scale is marked or graduated, then you use a scale_ function.
    - Many scales come with a legend or key to help the reader interpret the graph. These are called guides. You can make adjustments to them with the guides() function. Perhaps the most common use case is to make the legend disappear, as it is sometimes superfluous. Another is to adjust the arrangement of the key in legends and colorbars.
    - Graphs have other features not strictly connected to the logical structure of the data being displayed. These include things like their background color, the typeface used for labels, or the placement of the legend on the graph. To adjust these, use the theme() function.

```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors,
                          color = world))
p + geom_point()
```

Kuvaajaa yllä "shows a plot with three aesthetic mappings. The variable roads is mapped to x; donors is mapped to y; and world is mapped to color." --> **kolme muuttujaa, kolme asteikkoa!**

Asteikkoja(akseleita) voi säätää:

```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors,
                          color = world))
p + geom_point() +
    scale_x_log10() +
    scale_y_continuous(breaks = c(5, 15, 25),
                       labels = c("Five", "Fifteen", "Twenty Five"))
```

Myös väri- ja muotoasteikkoja voi säätää

```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors,
                          color = world))
p + geom_point() +
    scale_color_discrete(labels =
                             c("Corporatist", "Liberal",
                               "Social Democratic", "Unclassified")) +
    labs(x = "Road Deaths",
         y = "Donor Procurement",
        color = "Welfare State")
```

## Work with Models

The geom_smooth() function can take a range of method arguments to fit LOESS, OLS, and robust regression lines, amongst others.

- MASS library’s rlm function to fit a robust regression line
- In the second panel, the bs function is invoked directly from the splines library in the same way, to fit a polynominal curve to the data
-  The geom_quantile() function, meanwhile, is like a specialized version of geom_smooth() that can fit quantile regression lines using a variety of methods. The quantiles argument takes a vector specifying the quantiles at which to fit the lines.

```{r}
p <- ggplot(gapminder, aes(x = log(gdpPercap), y = lifeExp))

p + geom_point(alpha=0.1) + geom_smooth(color = "tomato", fill = " tomato", method = MASS::rlm) + geom_smooth(color = "blue", fill="blue", method = "lm")

p + geom_point(alpha=0.1) +
    geom_smooth(color = "purple", method = "lm", size = 1.2, 
                formula = y ~ splines::bs(x, 3), se = FALSE)

p + geom_point(alpha=0.1) +
    geom_quantile(color = "green", size = 1.2, method = "rqss",
                  lambda = 1, quantiles = c(0.20, 0.5, 0.85))
```

Malleja voi sovittaa useamman kuvaajaan ja lisätä niille legendat

```{r}
model_colors <- RColorBrewer::brewer.pal(3, "Set1")
model_colors

p0 <- ggplot(data = gapminder,
            mapping = aes(x = log(gdpPercap), y = lifeExp))

p1 <- p0 + geom_point(alpha = 0.2) +
    geom_smooth(method = "lm", aes(color = "OLS", fill = "OLS")) +
    geom_smooth(method = "lm", formula = y ~ splines::bs(x, df = 3),
                aes(color = "Cubic Spline", fill = "Cubic Spline")) +
    geom_smooth(method = "loess",
                aes(color = "LOESS", fill = "LOESS"))


p1 + scale_color_manual(name = "Models", values = model_colors) +
    scale_fill_manual(name = "Models", values = model_colors) +
    theme(legend.position = "top")
```

Figures based on statistical models face all the ordinary challenges of effective data visualization, and then some. This is because model results usually carry a considerable extra burden of interpretation and necessary background knowledge. The more complex the model, the trickier it becomes to convey this information effectively, and the easier it becomes to lead one’s audience or oneself into error.

Some kinds of models are quite tricky to understand, even ones that had previously been seen as straightforward elements of the modeling toolkit (Ai & Norton, 2003; Brambor, Clark, & Golder, 2006).

Plotting model estimates is closely connected to properly estimating models in the first place. This means **there is no substitute for learning the statistics. You should not use graphical methods as a substitute for understanding the model used to produce them.**

Presenting substantively interpretable findings often also means using (and sometimes converting to) a scale that readers can easily understand. If your model reports **results in log-odds**, for example, converting the estimates **to predicted probabilities** will make it easier to interpret.

A family of related ggplot geoms allow you to show a range or interval defined by position on the x-axis and then a ymin and ymax range on the y-axis. These geoms include **geom_pointrange()** and **geom_errorbar()**, which we will see in action shortly. A related geom, geom_ribbon() uses the same arguments to draw filled areas, and is useful for plotting ranges of y-axis values along some continuously varying x-axis.

## Draw Maps

```{r}

```


## Refine your Plots

```{r}

```


